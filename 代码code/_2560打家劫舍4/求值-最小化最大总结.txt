--这道题可以转换成--数组的子序列（一定不出现连续的两个以上的数），然后选出其中最大的数--求一个数（这个数虽然是在一个零散的数组，但同样可以使用二分法）
——————————
已经证明是错的--自己的部分分析--存在最优方法--如果排序后的数组，取n个数刚好都不是邻居，但答案不能这样证明
——————————
--我的思想--排序后判断是否是邻居所需成太大--所以跳过判断邻居--找出不需要判断的方法
--本题目类型--最小化最大值问题--在一个大范围中选出一个小的范围，选出小范围里面的最大--会得到一堆最大值，选出其中最小的一个
--代码的方法是二分法
——本题目中，最难的不是二分，而是能够使用二分的前提--fy函数
--1原本是房屋确定，金额不确定--将最小的金额转换成最小的房屋数--也就是金额确定，房屋不确定
--2思想从一个零散点中求一个数，变成从实数集中求解一个数，只需要判断这个数是否符合条件与否，不需要考虑决策（选那个点）的依赖关系
--3这道题注意判断依赖的深浅,不要将这道题搞成动态规划--这道题只求一个值，是浅依赖，如果是求和，可能是深依赖
——————————
--代码知识
1关于二分法如何得出最终答案(是lower？还是uppper？），和二分法如何设置循环条件（<？还是<=？)的探讨
2求数组的最大值最小值（不是返回位置）
int max = *max_element(nums.begin(), nums.end());
        int min = *min_element(nums.begin(), nums.end());
--这个函数是在[nums.begin(), nums.end())这个区间内寻找极值的容器--如果不带*号，返回的是极值位置，要注意的是如果有多个最大值或者最小值，返回的是第一次出现的位置
